/* SassParser.java */
/* Generated By:JavaCC: Do not edit this line. SassParser.java */
public class SassParser implements SassParserConstants {

  static final public void parseLine() throws ParseException {
    operation();
    jj_consume_token(EOL);
  }

  static final public void operation() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MSET:{
      memSet();
      break;
      }
    case JUMP:{
      jump();
      break;
      }
    case JSR:{
      jsr();
      break;
      }
    case RET:{
      ret();
      break;
      }
    case TEQS:{
      testEqualString();
      break;
      }
    case TNES:{
      testNotEqualString();
      break;
      }
    case TGTS:{
      testGreaterString();
      break;
      }
    case TGES:{
      testGreaterEqualString();
      break;
      }
    case TLTS:{
      testLessString();
      break;
      }
    case TLES:{
      testLessEqualString();
      break;
      }
    case TEQN:{
      testEqualNumber();
      break;
      }
    case TNEN:{
      testNotEqualNumber();
      break;
      }
    case TGTN:{
      testGreaterNumber();
      break;
      }
    case TGEN:{
      testGreaterEqualNumber();
      break;
      }
    case TLTN:{
      testLessNumber();
      break;
      }
    case TLEN:{
      testLessEqualNumber();
      break;
      }
    case TNUM:{
      testNumber();
      break;
      }
    case MOVE:{
      move();
      break;
      }
    case ADD:{
      add();
      break;
      }
    case CHAR:{
      chatAt();
      break;
      }
    case LGTH:{
      length();
      break;
      }
    case SUB:{
      subtract();
      break;
      }
    case DIV:{
      divide();
      break;
      }
    case MUL:{
      multiply();
      break;
      }
    case CAT:{
      concat();
      break;
      }
    case EXIT:{
      exit();
      break;
      }
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void memSet() throws ParseException {Token t;
    jj_consume_token(MSET);
    t = jj_consume_token(NUMBER);
SassCore.memSet((int)Double.parseDouble(t.toString()));
  }

  static final public void length() throws ParseException {String a;
    jj_consume_token(LGTH);
    a = source();
SassCore.accumulator = Integer.toString(a.length());
  }

  static final public void testEqualString() throws ParseException {String a, b;
    jj_consume_token(TEQS);
    a = source();
    b = source();
if(!a.equals(b)) SassCore.skipLine();
  }

  static final public void testNotEqualString() throws ParseException {String a, b;
    jj_consume_token(TNES);
    a = source();
    b = source();
if(a.equals(b)) SassCore.skipLine();
  }

  static final public void testGreaterString() throws ParseException {String a, b;
    jj_consume_token(TGTS);
    a = source();
    b = source();
if(!(a.compareTo(b) > 0)) SassCore.skipLine();
  }

  static final public void testGreaterEqualString() throws ParseException {String a, b;
    jj_consume_token(TGES);
    a = source();
    b = source();
if(!(a.compareTo(b) >= 0)) SassCore.skipLine();
  }

  static final public void testLessString() throws ParseException {String a, b;
    jj_consume_token(TLTS);
    a = source();
    b = source();
if(!(a.compareTo(b) < 0)) SassCore.skipLine();
  }

  static final public void testLessEqualString() throws ParseException {String a, b;
    jj_consume_token(TLES);
    a = source();
    b = source();
if(!(a.compareTo(b) <= 0)) SassCore.skipLine();
  }

  static final public void testEqualNumber() throws ParseException {String a, b;
    jj_consume_token(TEQN);
    a = source();
    b = source();
if(Double.parseDouble(a) != Double.parseDouble(b)) SassCore.skipLine();
  }

  static final public void testNotEqualNumber() throws ParseException {String a, b;
    jj_consume_token(TNEN);
    a = source();
    b = source();
if(Double.parseDouble(a) == Double.parseDouble(b)) SassCore.skipLine();
  }

  static final public void testGreaterNumber() throws ParseException {String a, b;
    jj_consume_token(TGTN);
    a = source();
    b = source();
if(!(Double.parseDouble(a) > Double.parseDouble(b))) SassCore.skipLine();
  }

  static final public void testGreaterEqualNumber() throws ParseException {String a, b;
    jj_consume_token(TGEN);
    a = source();
    b = source();
if(!(Double.parseDouble(a) >= Double.parseDouble(b))) SassCore.skipLine();
  }

  static final public void testLessNumber() throws ParseException {String a, b;
    jj_consume_token(TLTN);
    a = source();
    b = source();
if(!(Double.parseDouble(a) < Double.parseDouble(b))) SassCore.skipLine();
  }

  static final public void testLessEqualNumber() throws ParseException {String a, b;
    jj_consume_token(TLEN);
    a = source();
    b = source();
if(!(Double.parseDouble(a) <= Double.parseDouble(b))) SassCore.skipLine();
  }

  static final public void testNumber() throws ParseException {String a;
    jj_consume_token(TNUM);
    a = source();
if(!a.matches(SassCore._number)) SassCore.skipLine();
  }

  static final public void concat() throws ParseException {String a, b;
    jj_consume_token(CAT);
    a = source();
    b = source();
SassCore.accumulator = a+b;
  }

  static final public void chatAt() throws ParseException {String a, b;
    jj_consume_token(CHAR);
    a = source();
    b = source();
SassCore.accumulator = String.valueOf(a.charAt((int)Double.parseDouble(b)));
  }

  static final public void add() throws ParseException {String a;
    String b;
    jj_consume_token(ADD);
    a = source();
    b = source();
SassCore.accumulator = Double.toString(Double.parseDouble(a) + Double.parseDouble(b));
  }

  static final public void subtract() throws ParseException {String a;
    String b;
    jj_consume_token(SUB);
    a = source();
    b = source();
SassCore.accumulator = Double.toString(Double.parseDouble(a) - Double.parseDouble(b));
  }

  static final public void divide() throws ParseException {String a;
    String b;
    jj_consume_token(DIV);
    a = source();
    b = source();
SassCore.accumulator = Double.toString(Double.parseDouble(a) / Double.parseDouble(b));
  }

  static final public void multiply() throws ParseException {String a;
    String b;
    jj_consume_token(MUL);
    a = source();
    b = source();
SassCore.accumulator = Double.toString(Double.parseDouble(a) * Double.parseDouble(b));
  }

  static final public void move() throws ParseException {String a;
    jj_consume_token(MOVE);
    a = source();
    destination(a);
  }

  static final public void jump() throws ParseException {Token t;
    jj_consume_token(JUMP);
    t = jj_consume_token(LABEL);
SassCore.jump(t.toString());
  }

  static final public void jsr() throws ParseException {Token t;
    jj_consume_token(JSR);
    t = jj_consume_token(LABEL);
SassCore.beginSubroutine(t.toString());
  }

  static final public void ret() throws ParseException {
    jj_consume_token(RET);
SassCore.endSubroutine();
  }

  static final public void exit() throws ParseException {
    jj_consume_token(EXIT);
System.exit(-1);
  }

  static final public void destination(String a) throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OUT:{
      jj_consume_token(OUT);
IO.out(a);
      break;
      }
    case POINTER:{
      t = jj_consume_token(POINTER);
SassCore.setPointer(t.toString(), (int)Double.parseDouble(a));
      break;
      }
    case ACC:{
      jj_consume_token(ACC);
SassCore.accumulator = a;
      break;
      }
    case PUSH:{
      jj_consume_token(PUSH);
SassCore.memPush(a);
      break;
      }
    case DATA:{
      jj_consume_token(DATA);
SassCore.register[0] = a;
      break;
      }
    case DATB:{
      jj_consume_token(DATB);
SassCore.register[1] = a;
      break;
      }
    case DATC:{
      jj_consume_token(DATC);
SassCore.register[2] = a;
      break;
      }
    case DATD:{
      jj_consume_token(DATD);
SassCore.register[3] = a;
      break;
      }
    case ADDR:{
      jj_consume_token(ADDR);
SassCore.address = (int)Double.parseDouble(a);
      break;
      }
    case MEM:{
      jj_consume_token(MEM);
SassCore.memory[SassCore.address] = a;
      break;
      }
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public String source() throws ParseException {String a;
    Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IN:{
      jj_consume_token(IN);
a=IO.in();
      break;
      }
    case STRING:{
      t = jj_consume_token(STRING);
a = t.toString();
                        a = a.substring(1,a.length()-1);
      break;
      }
    case NUMBER:{
      t = jj_consume_token(NUMBER);
a = t.toString();
      break;
      }
    case POINTER:{
      t = jj_consume_token(POINTER);
a = Integer.toString(SassCore.getPointer(t.toString()));
      break;
      }
    case ACC:{
      jj_consume_token(ACC);
a=SassCore.accumulator;
      break;
      }
    case POP:{
      jj_consume_token(POP);
a=SassCore.memPop();
      break;
      }
    case TOP:{
      jj_consume_token(TOP);
a=SassCore.memTop();
      break;
      }
    case DATA:{
      jj_consume_token(DATA);
a=SassCore.register[0];
      break;
      }
    case DATB:{
      jj_consume_token(DATB);
a=SassCore.register[1];
      break;
      }
    case DATC:{
      jj_consume_token(DATC);
a=SassCore.register[2];
      break;
      }
    case DATD:{
      jj_consume_token(DATD);
a=SassCore.register[3];
      break;
      }
    case ADDR:{
      jj_consume_token(ADDR);
a=Integer.toString(SassCore.address);
      break;
      }
    case MEM:{
      jj_consume_token(MEM);
a=SassCore.memory[SassCore.address];
      break;
      }
    case RAND:{
      jj_consume_token(RAND);
a=Double.toString(SassCore.random());
      break;
      }
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return a;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** User defined Token Manager. */
  static public TokenManager token_source;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[3];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x3bfffff4,0xc0000000,0x80000008,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0xff,0x1ffd,};
   }


  /** Constructor with user supplied Token Manager. */
  public SassParser(TokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 3; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[45];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 3; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 45; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

 }
